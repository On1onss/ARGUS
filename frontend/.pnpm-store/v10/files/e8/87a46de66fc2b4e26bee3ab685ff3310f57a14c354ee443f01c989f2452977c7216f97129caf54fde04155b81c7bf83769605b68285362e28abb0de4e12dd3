'use client'
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AreaChart: () => AreaChart2,
  BarChart: () => BarChart,
  ChartTooltip: () => ChartTooltip,
  LineChart: () => LineChart,
  Sparkline: () => Sparkline,
  Sparklines: () => Sparklines
});
module.exports = __toCommonJS(src_exports);

// src/sparkline.tsx
var import_react = require("@chakra-ui/react");
var import_recharts = require("recharts");

// src/utils.ts
var createCategoryColors = (categories, colors, theme) => {
  return Object.fromEntries(
    categories.map((category, index) => {
      var _a;
      const color = getColor((_a = colors[index]) != null ? _a : "gray.500", theme);
      return [category, color];
    })
  );
};
var getColor = (color, theme) => {
  var _a;
  if (color.match(/\.[0-9]{2,3}/)) {
    return `var(--chakra-colors-${color.replace(".", "-")})`;
  } else if (theme.colors[color]) {
    return (_a = theme.colors[color]) == null ? void 0 : _a[500];
  }
  return color;
};

// src/sparkline.tsx
var import_react2 = require("react");
var import_jsx_runtime = require("react/jsx-runtime");
var Sparkline = (props) => {
  const {
    data = [],
    categories = ["value"],
    curveType,
    colors = ["primary", "gray"],
    strokeWidth = 1,
    variant = "gradient",
    showAnimation = false,
    animationDuration = 500,
    connectNulls = true,
    stack = false,
    ...rest
  } = props;
  const theme = (0, import_react.useTheme)();
  const id = (0, import_react2.useId)();
  const categoryColors = createCategoryColors(categories, colors, theme);
  const getColor2 = (category) => {
    return categoryColors[category];
  };
  const getGradientId = (category) => {
    return `${id}-${category}-gradient`;
  };
  const getFill = (category) => {
    switch (variant) {
      case "solid":
        return getColor2(category);
      case "gradient":
        return `url(#${getGradientId(category)})`;
      default:
        return "transparent";
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_react.Box,
    {
      ...rest,
      sx: {
        "--sparkline-fill-opacity": "0.2",
        "--sparkline-gradient-start-opacity": "0.8",
        "--sparkline-gradient-end-opacity": "0",
        ...rest.sx
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_recharts.ResponsiveContainer, { width: "100%", height: "100%", minWidth: "0", children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
        import_recharts.AreaChart,
        {
          data,
          margin: { top: 2, right: 0, left: 0, bottom: 0 },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("defs", { children: categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
              "linearGradient",
              {
                id: getGradientId(category),
                x1: "0",
                y1: "0",
                x2: "0",
                y2: "1",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "stop",
                    {
                      offset: "5%",
                      stopColor: getColor2(category),
                      stopOpacity: "var(--sparkline-gradient-start-opacity))"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "stop",
                    {
                      offset: "95%",
                      stopColor: getColor2(category),
                      stopOpacity: "var(--sparkline-gradient-end-opacity)"
                    }
                  )
                ]
              },
              category
            )) }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
              import_recharts.YAxis,
              {
                tick: false,
                axisLine: false,
                width: 0,
                domain: ["dataMin", "dataMax"]
              }
            ),
            categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
              import_recharts.Area,
              {
                dataKey: category,
                stroke: getColor2(category),
                strokeWidth,
                fill: getFill(category),
                fillOpacity: "var(--sparkline-fill-opacity)",
                type: curveType,
                isAnimationActive: showAnimation,
                animationDuration,
                connectNulls,
                stackId: stack ? "a" : void 0
              },
              category
            ))
          ]
        }
      ) })
    }
  );
};
var Sparklines = Sparkline;

// src/area-chart.tsx
var React2 = __toESM(require("react"));
var import_react6 = require("@chakra-ui/react");
var import_recharts2 = require("recharts");

// src/legend.tsx
var import_react3 = require("@chakra-ui/react");
var import_jsx_runtime2 = require("react/jsx-runtime");
var ChartLegend = (0, import_react3.forwardRef)(
  ({ payload, categoryColors }, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_react3.HStack, { ref, justifyContent: "flex-end", spacing: "2", children: payload == null ? void 0 : payload.map((entry, index) => {
      var _a;
      return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_react3.HStack, { spacing: "1", children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          import_react3.Box,
          {
            rounded: "full",
            bg: (_a = categoryColors[entry.value]) != null ? _a : entry.color,
            boxSize: "2"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_react3.Box, { as: "span", children: entry.value })
      ] }, `item-${index}`);
    }) });
  }
);

// src/tooltip.tsx
var import_react4 = require("@chakra-ui/react");
var import_react5 = __toESM(require("react"));
var import_jsx_runtime3 = require("react/jsx-runtime");
var ChartTooltip = (props) => {
  const {
    categoryColors,
    contentStyle = {},
    itemStyle = {},
    labelStyle = {},
    payload,
    formatter,
    wrapperClassName,
    labelClassName,
    label,
    labelFormatter
  } = props;
  const tooltipTheme = (0, import_react4.useStyleConfig)("Tooltip");
  const renderContent = () => {
    if (payload && payload.length) {
      const items = payload.map((entry, i) => {
        var _a, _b;
        if (entry.type === "none" || entry.value === void 0 || entry.name === void 0) {
          return null;
        }
        const finalItemStyle = {
          paddingTop: 2,
          paddingBottom: 2,
          ...itemStyle
        };
        const finalFormatter = entry.formatter || formatter;
        const { value, name } = entry;
        let finalValue = value;
        let finalName = name;
        if (finalFormatter && finalValue != null && finalName != null) {
          const formatted = (_a = finalFormatter == null ? void 0 : finalFormatter(value, name, entry, i, payload)) != null ? _a : value;
          if (Array.isArray(formatted)) {
            ;
            [finalValue, finalName] = formatted;
          } else {
            finalValue = formatted;
          }
        }
        return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
          import_react4.HStack,
          {
            as: "li",
            style: finalItemStyle,
            spacing: "1",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
                import_react4.Box,
                {
                  rounded: "full",
                  bg: (_b = categoryColors[entry.name]) != null ? _b : entry.color,
                  boxSize: "2"
                }
              ),
              finalName ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
                import_react4.Box,
                {
                  flex: "1",
                  minWidth: "80px",
                  color: "var(--tooltip-fg-muted, var(--chakra-colors-muted))",
                  children: finalName
                }
              ) : null,
              /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_react4.Box, { textAlign: "right", children: [
                /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { children: finalValue }),
                /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { children: entry.unit || "" })
              ] })
            ]
          },
          `tooltip-item-${i}`
        );
      });
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react4.Box, { as: "ul", children: items });
    }
    return null;
  };
  const hasLabel = !!label;
  let finalLabel = hasLabel ? label : "";
  if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) {
    finalLabel = labelFormatter(label, payload);
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
    import_react4.Box,
    {
      outline: "none",
      flexDirection: "column",
      className: wrapperClassName,
      style: contentStyle,
      sx: tooltipTheme,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react4.Text, { w: "full", className: labelClassName, style: labelStyle, children: import_react5.default.isValidElement(finalLabel) ? finalLabel : `${finalLabel}` }),
        renderContent()
      ]
    }
  );
};

// src/area-chart.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var AreaChart2 = React2.forwardRef(
  (props, ref) => {
    const {
      data = [],
      categories = [],
      colors = ["primary", "cyan"],
      height,
      connectNulls = false,
      curveType = "linear",
      index = "date",
      startEndOnly = false,
      intervalType = "equidistantPreserveStart",
      allowDecimals = true,
      strokeWidth = 2,
      showAnimation = true,
      showGrid = true,
      showLegend = true,
      showTooltip = true,
      showXAxis = true,
      showYAxis = true,
      stack = false,
      stackOffset,
      yAxisWidth = 40,
      legendHeight = 32,
      animationDuration = 500,
      valueFormatter,
      variant = "gradient",
      tooltipContent,
      children,
      minValue = 0,
      maxValue = "auto"
    } = props;
    const theme = (0, import_react6.useTheme)();
    const id = React2.useId();
    const categoryColors = createCategoryColors(categories, colors, theme);
    const getColor2 = (category) => {
      return categoryColors[category];
    };
    const getGradientId = (category) => {
      return `${id}-${category}-gradient`;
    };
    const getFill = (category) => {
      switch (variant) {
        case "solid":
          return getColor2(category);
        case "gradient":
          return `url(#${getGradientId(category)})`;
        default:
          return "transparent";
      }
    };
    const yAxisDomain = [minValue, maxValue];
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      import_react6.Box,
      {
        ref,
        height,
        fontSize: "sm",
        sx: {
          "--chart-gradient-start-opacity": "0.8",
          "--chart-gradient-end-opacity": "0"
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_recharts2.ResponsiveContainer, { width: "100%", height: "100%", minWidth: "0", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_recharts2.AreaChart, { data, stackOffset, children: [
          showGrid && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            import_recharts2.CartesianGrid,
            {
              strokeDasharray: " 1 1 1",
              vertical: false,
              strokeOpacity: (0, import_react6.useColorModeValue)(0.8, 0.3)
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            import_recharts2.XAxis,
            {
              padding: { left: 20, right: 20 },
              dataKey: index,
              hide: !showXAxis,
              tick: { transform: "translate(0, 6)" },
              ticks: startEndOnly ? [data[0][index], data[data.length - 1][index]] : void 0,
              interval: startEndOnly ? "preserveStartEnd" : intervalType,
              tickLine: false,
              axisLine: false,
              minTickGap: 5,
              style: {
                color: "var(--chakra-colors-muted)"
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            import_recharts2.YAxis,
            {
              width: yAxisWidth,
              hide: !showYAxis,
              axisLine: false,
              tickLine: false,
              tick: { transform: "translate(-3, 0)" },
              tickCount: 6,
              type: "number",
              tickFormatter: valueFormatter,
              allowDecimals,
              domain: yAxisDomain,
              style: {
                color: "var(--chakra-colors-muted)"
              }
            }
          ),
          showTooltip && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            import_recharts2.Tooltip,
            {
              formatter: valueFormatter,
              content: tooltipContent ? tooltipContent : (props2) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                ChartTooltip,
                {
                  ...props2,
                  categoryColors
                }
              )
            }
          ),
          showLegend && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            import_recharts2.Legend,
            {
              verticalAlign: "top",
              align: "right",
              height: legendHeight,
              content: ({ payload }) => {
                return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                  ChartLegend,
                  {
                    payload,
                    categoryColors
                  }
                );
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("defs", { children: categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
            "linearGradient",
            {
              id: getGradientId(category),
              x1: "0",
              y1: "0",
              x2: "0",
              y2: "1",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                  "stop",
                  {
                    offset: "5%",
                    stopColor: getColor2(category),
                    stopOpacity: "var(--chart-gradient-start-opacity)"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                  "stop",
                  {
                    offset: "95%",
                    stopColor: getColor2(category),
                    stopOpacity: "var(--chart-gradient-end-opacity)"
                  }
                )
              ]
            },
            category
          )) }),
          children,
          categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            import_recharts2.Area,
            {
              type: curveType,
              dataKey: category,
              stroke: getColor2(category),
              strokeWidth,
              strokeLinejoin: "round",
              strokeLinecap: "round",
              fill: getFill(category),
              isAnimationActive: showAnimation,
              animationDuration,
              stackId: stack ? "a" : void 0,
              connectNulls
            },
            category
          ))
        ] }) })
      }
    );
  }
);

// src/line-chart.tsx
var React3 = __toESM(require("react"));
var import_react7 = require("@chakra-ui/react");
var import_recharts3 = require("recharts");
var import_jsx_runtime5 = require("react/jsx-runtime");
var LineChart = React3.forwardRef(
  (props, ref) => {
    const {
      data = [],
      categories = [],
      colors = ["primary"],
      height,
      connectNulls = false,
      curveType = "linear",
      dot = false,
      index = "date",
      startEndOnly = false,
      intervalType = "equidistantPreserveStart",
      allowDecimals = true,
      strokeWidth = 2,
      showAnimation = true,
      showGrid = true,
      showLegend = true,
      showTooltip = true,
      showXAxis = true,
      showYAxis = true,
      yAxisWidth = 40,
      legendHeight = 32,
      animationDuration = 500,
      minValue = 0,
      maxValue = "auto",
      valueFormatter,
      tooltipContent,
      children
    } = props;
    const theme = (0, import_react7.useTheme)();
    const categoryColors = createCategoryColors(categories, colors, theme);
    const getColor2 = (category) => {
      return categoryColors[category];
    };
    const yAxisDomain = [minValue, maxValue];
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react7.Box, { ref, height, fontSize: "sm", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_recharts3.ResponsiveContainer, { width: "100%", height: "100%", minWidth: "0", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_recharts3.LineChart, { data, children: [
      showGrid && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        import_recharts3.CartesianGrid,
        {
          strokeDasharray: " 1 1 1",
          vertical: false,
          strokeOpacity: (0, import_react7.useColorModeValue)(0.8, 0.3)
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        import_recharts3.XAxis,
        {
          padding: { left: 20, right: 20 },
          dataKey: index,
          hide: !showXAxis,
          tick: { transform: "translate(0, 6)" },
          ticks: startEndOnly ? [data[0][index], data[data.length - 1][index]] : void 0,
          interval: startEndOnly ? "preserveStartEnd" : intervalType,
          tickLine: false,
          axisLine: false,
          minTickGap: 5,
          style: {
            color: "var(--chakra-colors-muted)"
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        import_recharts3.YAxis,
        {
          width: yAxisWidth,
          hide: !showYAxis,
          axisLine: false,
          tickLine: false,
          domain: yAxisDomain,
          tick: { transform: "translate(-3, 0)" },
          tickCount: 6,
          type: "number",
          tickFormatter: valueFormatter,
          allowDecimals,
          style: {
            color: "var(--chakra-colors-muted)"
          }
        }
      ),
      showTooltip && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        import_recharts3.Tooltip,
        {
          formatter: valueFormatter,
          content: tooltipContent ? tooltipContent : (props2) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            ChartTooltip,
            {
              ...props2,
              categoryColors
            }
          )
        }
      ),
      showLegend && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        import_recharts3.Legend,
        {
          verticalAlign: "top",
          align: "right",
          height: legendHeight,
          content: ({ payload }) => {
            return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
              ChartLegend,
              {
                payload,
                categoryColors
              }
            );
          }
        }
      ),
      children,
      categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        import_recharts3.Line,
        {
          type: curveType,
          dataKey: category,
          dot,
          stroke: getColor2(category),
          strokeWidth,
          strokeLinejoin: "round",
          strokeLinecap: "round",
          isAnimationActive: showAnimation,
          animationDuration,
          connectNulls
        },
        category
      ))
    ] }) }) });
  }
);

// src/bar-chart.tsx
var React4 = __toESM(require("react"));
var import_react8 = require("@chakra-ui/react");
var import_recharts4 = require("recharts");
var import_jsx_runtime6 = require("react/jsx-runtime");
var BarChart = React4.forwardRef(
  (props, ref) => {
    const {
      data = [],
      categories = [],
      colors = ["primary", "cyan"],
      height,
      index = "date",
      barGap = "2",
      barCategoryGap = "10%",
      barSize,
      startEndOnly = false,
      intervalType = "equidistantPreserveStart",
      allowDecimals = true,
      showAnimation = true,
      showGrid = true,
      showLegend = true,
      showTooltip = true,
      showXAxis = true,
      showYAxis = true,
      stack = false,
      stackOffset,
      yAxisWidth = 40,
      legendHeight = 32,
      animationDuration = 500,
      minValue = 0,
      maxValue = "auto",
      valueFormatter,
      variant = "gradient",
      tooltipContent,
      radius = stack ? 0 : [2, 2, 0, 0],
      children
    } = props;
    const theme = (0, import_react8.useTheme)();
    const id = React4.useId();
    const categoryColors = createCategoryColors(categories, colors, theme);
    const getColor2 = (category) => {
      return categoryColors[category];
    };
    const getGradientId = (category) => {
      return `${id}-${category}-gradient`;
    };
    const getFill = (category) => {
      switch (variant) {
        case "solid":
          return getColor2(category);
        case "gradient":
          return `url(#${getGradientId(category)})`;
        default:
          return "transparent";
      }
    };
    const yAxisDomain = [minValue, maxValue];
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
      import_react8.Box,
      {
        ref,
        height,
        fontSize: "sm",
        sx: {
          "--chart-cursor-bg": "var(--chakra-colors-blackAlpha-100)",
          "--chart-gradient-start-opacity": "0.8",
          "--chart-gradient-end-opacity": "80",
          _dark: {
            "--chart-cursor-bg": "var(--chakra-colors-whiteAlpha-100)",
            "--chart-gradient-start-opacity": "80",
            "--chart-gradient-end-opacity": "0.8"
          }
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_recharts4.ResponsiveContainer, { width: "100%", height: "100%", minWidth: "0", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
          import_recharts4.BarChart,
          {
            data,
            barCategoryGap,
            barGap,
            barSize,
            stackOffset,
            children: [
              showGrid && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                import_recharts4.CartesianGrid,
                {
                  strokeDasharray: " 1 1 1",
                  vertical: false,
                  strokeOpacity: (0, import_react8.useColorModeValue)(0.8, 0.3)
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                import_recharts4.XAxis,
                {
                  padding: { left: 20, right: 20 },
                  dataKey: index,
                  hide: !showXAxis,
                  tick: { transform: "translate(0, 6)" },
                  ticks: startEndOnly ? [data[0][index], data[data.length - 1][index]] : void 0,
                  interval: startEndOnly ? "preserveStartEnd" : intervalType,
                  tickLine: false,
                  axisLine: false,
                  minTickGap: 5,
                  style: {
                    color: "var(--chakra-colors-muted)"
                  }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                import_recharts4.YAxis,
                {
                  width: yAxisWidth,
                  hide: !showYAxis,
                  axisLine: false,
                  tickLine: false,
                  tick: { transform: "translate(-3, 0)" },
                  tickCount: 6,
                  type: "number",
                  tickFormatter: valueFormatter,
                  domain: yAxisDomain,
                  allowDecimals,
                  style: {
                    color: "var(--chakra-colors-muted)"
                  }
                }
              ),
              showTooltip && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                import_recharts4.Tooltip,
                {
                  formatter: valueFormatter,
                  cursor: { fill: "var(--chart-cursor-bg)" },
                  content: tooltipContent ? tooltipContent : (props2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                    ChartTooltip,
                    {
                      ...props2,
                      categoryColors
                    }
                  )
                }
              ),
              showLegend && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                import_recharts4.Legend,
                {
                  verticalAlign: "top",
                  align: "right",
                  height: legendHeight,
                  content: ({ payload }) => {
                    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                      ChartLegend,
                      {
                        payload,
                        categoryColors
                      }
                    );
                  }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("defs", { children: categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
                "linearGradient",
                {
                  id: getGradientId(category),
                  x1: "0",
                  y1: "0",
                  x2: "0",
                  y2: "1",
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                      "stop",
                      {
                        offset: "5%",
                        stopColor: getColor2(category),
                        stopOpacity: "var(--chart-gradient-start-opacity)"
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                      "stop",
                      {
                        offset: "95%",
                        stopColor: getColor2(category),
                        stopOpacity: "var(--chart-gradient-end-opacity)"
                      }
                    )
                  ]
                },
                category
              )) }),
              children,
              categories.map((category) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                import_recharts4.Bar,
                {
                  dataKey: category,
                  fill: getFill(category),
                  color: getColor2(category),
                  isAnimationActive: showAnimation,
                  animationDuration,
                  stackId: stack ? "a" : void 0,
                  radius
                },
                category
              ))
            ]
          }
        ) })
      }
    );
  }
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AreaChart,
  BarChart,
  ChartTooltip,
  LineChart,
  Sparkline,
  Sparklines
});
//# sourceMappingURL=index.js.map